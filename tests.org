* TODO

1. calculation state functions
2. calculation required
3. calculation restart
  a. Reading calculation in

* ase + Vasp



** co example
#+BEGIN_SRC python
from ase import Atoms, Atom
from vasp import Vasp
import logging
import os
#os.environ['ASE_VASP_COMMAND'] = '/home-research/zhongnanxu/opt/vasp-5.3.5/bin/vasp-vtst-beef-serial'

#os.system('rm -fr molecules/simple-co')

co = Atoms([Atom('C',[0,   0, 0]),
            Atom('O',[1.2, 0, 0])],
            cell=(6., 6., 6.))

calc = Vasp('molecules/simple-co', #output dir
            xc='PBE',  # the exchange-correlation functional
            nbands=6,  # number of bands
            encut=350, # planewave cutoff
            ismear=1,  # Methfessel-Paxton smearing
            sigma=0.01,# very small smearing factor for a molecule
            debug=logging.DEBUG,
            atoms=co)

print calc.get_potential_energy()

#print a.get_magnetic_moments()
#+END_SRC

#+RESULTS:
: -14.69111507

** co2
#+BEGIN_SRC python
from ase import Atoms, Atom
from vasp import Vasp

import os
os.environ['ASE_VASP_COMMAND'] = '/home-research/zhongnanxu/opt/vasp-5.3.5/bin/vasp-vtst-beef-serial'

#os.system('rm -fr molecules/co2')

atoms = Atoms([Atom('O',[4, 5, 5]),
               Atom('C',[5,   5, 5]),
               Atom('O',[6, 5, 5])],
              cell=(10, 10, 10))

calc = Vasp('molecules/co2', #output dir
            xc='PBE',  # the exchange-correlation functional
            encut=350, # planewave cutoff
            ibrion=1, nsw=2,
            atoms=atoms)

print 'p1: \n',atoms.positions
print atoms.get_potential_energy()
print 'p2: \n',atoms.positions

print 'f: ',atoms.get_forces()
#+END_SRC

#+RESULTS:
#+begin_example
p1:
[[ 2.47829296  5.          5.        ]
 [ 5.          5.          5.        ]
 [ 7.52170704  5.          5.        ]]
-4.35577086
p2:
[[ 2.478293  5.        5.      ]
 [ 5.        5.        5.      ]
 [ 7.521707  5.        5.      ]]
f:  [[ 2.47499768  0.          0.        ]
 [ 0.          0.          0.        ]
 [-2.47499768  0.          0.        ]]
#+end_example

#+BEGIN_SRC sh
rm -fr molecules/co2/*
#+END_SRC

#+RESULTS:

** co
#+BEGIN_SRC python
from ase import Atoms, Atom
from vasp import Vasp

import os
os.environ['ASE_VASP_COMMAND'] = '/home-research/zhongnanxu/opt/vasp-5.3.5/bin/vasp-vtst-beef-serial'

#os.system('rm -fr molecules/co')

atoms = Atoms([Atom('C', [4.42,   5., 5.]),
               Atom('O', [5.58,   5., 5.])],
              cell=[10, 10, 10])

print atoms.positions
calc = Vasp('molecules/co', #output dir
            xc='PBE',  # the exchange-correlation functional
            encut=350, # planewave cutoff
            ibrion=2, nsw=10,
            atoms=atoms)


print atoms.get_potential_energy()
print atoms.positions
print 'f: \n', atoms.get_forces()
#+END_SRC

#+RESULTS:
: [[ 4.42  5.    5.  ]
:  [ 5.58  5.    5.  ]]
: -14.80857838
: [[ 4.4289913  5.         5.       ]
:  [ 5.5710087  5.         5.       ]]
: f:
: [[-0.20633627  0.          0.        ]
:  [ 0.20633627  0.          0.        ]]

#+BEGIN_SRC python
a = '3'
print float(a)
#+END_SRC

#+RESULTS:
: 3.0
** read incar
At some point we need logic on whether parameters have changed. We work out some of this here for the incar.

Here is how to compare parameter sets.
#+BEGIN_SRC python
from vasp import Vasp
calc = Vasp('molecules/co')
print calc.parameters
print calc.default_parameters
print calc.parameters == calc.default_parameters
#+END_SRC

#+RESULTS:
: {'kpts': [1, 1, 1], 'ismear': 1, 'lcharge': False, 'xc': 'PBE', 'lwave': False, 'sigma': 0.1, 'pp': 'PBE'}
: {'kpts': [1, 1, 1], 'ismear': 1, 'lcharge': False, 'xc': 'PBE', 'lwave': False, 'sigma': 0.1, 'pp': 'PBE'}
: True

The read_incar function gets the parameters from the incar.
#+BEGIN_SRC python
from vasp import Vasp
calc = Vasp('molecules/co')
print calc.read_incar()
#+END_SRC

#+RESULTS:
: {'magmoms': [1.0, -1], 'lcharge': False, 'encut': 350, 'ibrion': 2, 'ismear': 1, 'lwave': False, 'sigma': 0.1, 'nsw': 'free'}

Now, the challenge is to see what has changed. When we read things in, and kwargs is empty, we have to assume what is in the files is correct.


Let's get the tags in the default_parameters
#+BEGIN_SRC python
from vasp import Vasp
calc = Vasp('molecules/co')
ip = calc.read_incar()
print {key: val  for key,val in ip.iteritems() if key in calc.default_parameters}

default_incar_parameters = {key: val for key, val
                            in Vasp.default_parameters.iteritems()
                            if key not in Vasp.special_kwargs}

print default_incar_parameters
print calc.kwargs
#+END_SRC

#+RESULTS:
: {'ismear': 1, 'lwave': False, 'sigma': 0.1, 'lcharge': False}
: {'ismear': 1, 'lwave': False, 'sigma': 0.1, 'lcharge': False}
: {}

** testing incar params

#+BEGIN_SRC python
from ase import Atoms, Atom
from vasp import Vasp

import os
os.environ['ASE_VASP_COMMAND'] = '/home-research/zhongnanxu/opt/vasp-5.3.5/bin/vasp-vtst-beef-serial'

#os.system('rm -fr molecules/co')

atoms = Atoms([Atom('C', [4.42,   5., 5.]),
               Atom('O', [5.58,   5., 5.])],
              cell=[10, 10, 10])

print atoms.positions
calc = Vasp('molecules/co', #output dir
            xc='PBE',  # the exchange-correlation functional
            encut=350, # planewave cutoff
            ibrion=2, nsw=10,
            atoms=atoms)
print calc.parameters
print calc.read_incar()
#+END_SRC

#+RESULTS:
: [[ 4.42  5.    5.  ]
:  [ 5.58  5.    5.  ]]
: {'kpts': [1, 1, 1], 'lcharge': False, 'xc': 'PBE', 'pp': 'PBE', 'encut': 350, 'ibrion': 2, 'ismear': 1, 'lwave': False, 'sigma': 0.1, 'nsw': 10}
: {'magmoms': [1.0, -1], 'lcharge': False, 'encut': 350, 'ibrion': 2, 'ismear': 1, 'lwave': False, 'sigma': 0.1, 'nsw': 'free'}

** test reading kpoints
#+BEGIN_SRC python
from ase import Atoms, Atom
from vasp import Vasp

import os
os.environ['ASE_VASP_COMMAND'] = '/home-research/zhongnanxu/opt/vasp-5.3.5/bin/vasp-vtst-beef-serial'

#os.system('rm -fr molecules/co')

atoms = Atoms([Atom('C', [4.42,   5., 5.]),
               Atom('O', [5.58,   5., 5.])],
              cell=[10, 10, 10])

print atoms.positions
calc = Vasp('molecules/co', #output dir
            xc='PBE',  # the exchange-correlation functional
            encut=350, # planewave cutoff
            ibrion=2, nsw=10,
            atoms=atoms)
print calc.parameters
print calc.read_kpoints()
#+END_SRC

#+RESULTS:
: [[ 4.42  5.    5.  ]
:  [ 5.58  5.    5.  ]]
: {'kpts': [1, 1, 1], 'lcharge': False, 'xc': 'PBE', 'pp': 'PBE', 'encut': 350, 'ibrion': 2, 'ismear': 1, 'lwave': False, 'sigma': 0.1, 'nsw': 10}
: {'kpts': [1, 1, 1]}

** Read POTCAR
#+BEGIN_SRC python
from ase import Atoms, Atom
from vasp import Vasp

import os
os.environ['ASE_VASP_COMMAND'] = '/home-research/zhongnanxu/opt/vasp-5.3.5/bin/vasp-vtst-beef-serial'

#os.system('rm -fr molecules/co')

atoms = Atoms([Atom('C', [4.42,   5., 5.]),
               Atom('O', [5.58,   5., 5.])],
              cell=[10, 10, 10])

print atoms.positions
calc = Vasp('molecules/co', #output dir
            xc='PBE',  # the exchange-correlation functional
            encut=350, # planewave cutoff
            ibrion=2, nsw=10, setups=[['O', '_s']],
            atoms=atoms)
print calc.write_input(atoms)

p = {}
p.update(calc.read_incar())
p.update(calc.read_kpoints())
p.update(calc.read_potcar())

print p
print calc.parameters
#+END_SRC

#+RESULTS:
: [[ 4.42  5.    5.  ]
:  [ 5.58  5.    5.  ]]
: None
: {'kpts': [1, 1, 1], 'ibrion': 2, 'lcharge': False, 'setups': [['O', '_s']], 'ismear': 1, 'lwave': False, 'sigma': 0.1, 'pp': 'PBE', 'encut': 350, 'nsw': 10}
: {'kpts': [1, 1, 1], 'xc': 'PBE', 'encut': 350, 'ibrion': 2, 'ismear': 1, 'nsw': 10, 'pp': 'PBE', 'lcharge': False, 'setups': [['O', '_s']], 'lwave': False, 'sigma': 0.1}


** the xc issue
Since we allow xc to expand to a set of tags, we do not have a great way yet to identify what xc is. We can try pattern matching, but it is tricky. Each xc is a dictionary, and the order of keys is arbitrary. So, we need to match patterns, by longest first.

#+BEGIN_SRC python
from vasp import Vasp
print Vasp.xc_defaults
#+END_SRC

#+RESULTS:
: {'optb86b-vdw': {'pp': 'LDA', 'aggac': 0.0, 'gga': 'MK', 'param2': 1.0, 'param1': 0.1234, 'luse_vdw': True}, 'lda': {'pp': 'LDA'}, 'm06l': {'pp': 'PBE', 'metagga': 'M06L'}, 'hf': {'aldac': 0.0, 'aggac': 0.0, 'pp': 'PBE', 'aexx': 1.0, 'lhfcalc': True}, 'beef-vdw': {'zab_vdw': -1.8867, 'pp': 'LDA', 'gga': 'BF', 'luse_vdw': True}, 'optpbe-vdw': {'pp': 'LDA', 'gga': 'OR', 'luse_vdw': True, 'aggac': 0.0}, 'revtpss': {'pp': 'PBE', 'metagga': 'RTPSS'}, 'b3lyp': {'pp': 'LDA', 'aggac': 0.81, 'aldac': 0.19, 'aexx': 0.2, 'gga': 'B3', 'lhfcalc': True, 'aggax': 0.72}, 'pbe': {'pp': 'PBE'}, 'rpbe': {'pp': 'LDA', 'gga': 'RP'}, 'tpss': {'pp': 'PBE', 'metagga': 'TPSS'}, 'optb88-vdw': {'pp': 'LDA', 'aggac': 0.0, 'gga': 'BO', 'param2': 0.22, 'param1': 0.18333333333333335, 'luse_vdw': True}, 'hse03': {'pp': 'LDA', 'gga': 'PE', 'hfscreen': 0.3, 'lhfcalc': True}, 'vdw-df2': {'zab_vdw': -1.8867, 'pp': 'LDA', 'gga': 'ML', 'luse_vdw': True, 'aggac': 0.0}, 'pbesol': {'pp': 'LDA', 'gga': 'PS'}, 'am05': {'pp': 'LDA', 'gga': 'AM'}, 'revpbe': {'pp': 'LDA', 'gga': 'RE'}, None: {'pp': 'PBE'}}

#+BEGIN_SRC python
from vasp import Vasp
# Sort keys by largest number of options
exc = sorted(Vasp.xc_defaults, key=lambda k: len(Vasp.xc_defaults[k]), reverse=True)
print k
#+END_SRC

#+RESULTS:
: ['b3lyp', 'optb86b-vdw', 'optb88-vdw', 'hf', 'vdw-df2', 'beef-vdw', 'optpbe-vdw', 'hse03', 'm06l', 'revtpss', 'rpbe', 'tpss', 'pbesol', 'am05', 'revpbe', 'lda', 'pbe', None]

To determine which functional is used, I need to get all the options for a functional, and compare them to the subset of options in a calculation.

#+BEGIN_SRC python
from ase import Atoms, Atom
from vasp import Vasp

import os
os.environ['ASE_VASP_COMMAND'] = '/home-research/zhongnanxu/opt/vasp-5.3.5/bin/vasp-vtst-beef-serial'

#os.system('rm -fr molecules/co')

atoms = Atoms([Atom('C', [4.42,   5., 5.]),
               Atom('O', [5.58,   5., 5.])],
              cell=[10, 10, 10])

print atoms.positions
calc = Vasp('molecules/co', #output dir
            xc='PBE',  # the exchange-correlation functional
            encut=350, # planewave cutoff
            ibrion=2, nsw=10,
            atoms=atoms)
calc.write_input(atoms)
print calc.parameters
print calc.read()

print calc.parameters == calc.read()[1]
#+END_SRC

#+RESULTS:
: [[ 4.42  5.    5.  ]
:  [ 5.58  5.    5.  ]]
: {'kpts': [1, 1, 1], 'lcharge': False, 'xc': 'pbe', 'pp': 'PBE', 'encut': 350, 'ibrion': 2, 'ismear': 1, 'lwave': False, 'sigma': 0.1, 'nsw': 10}
: (Atoms(symbols='CO', positions=..., cell=[10.0, 10.0, 10.0], pbc=[True, True, True]), {'pp': 'PBE', 'ibrion': 2, 'xc': 'pbe', 'lcharge': False, 'ismear': 1, 'lwave': False, 'sigma': 0.1, 'kpts': [1, 1, 1], 'encut': 350, 'nsw': 10})
: True




* archive
** stuff

#+BEGIN_SRC python
from vasp import *

calc = Vasp('simple-co',
            encut=400,
            xc='beef-vdw',
            setups={'H': '_sv'},
            ldaul=(-1, 2),
            ldauu=[0, 0.2],
            ldauj=[0, 0.00],  kpts=(10, 10, 10))

# print dir(calc)
print calc.parameters
#print calc.special_kwargs
#print list(set(calc.parameters) - set(calc.special_kwargs))
#print {key: calc.parameters[key] for key in list(set(calc.parameters) - set(calc.special_kwargs))}
#calc.write_input(None)

#print open('simple-co/INCAR').read()

#print open('simple-co/KPOINTS').read()
#+END_SRC

#+RESULTS:
: {'kpts': (10, 10, 10), 'lcharge': False, 'xc': 'beef-vdw', 'ldaul': (-1, 2), 'ldauj': [0, 0.0], 'encut': 400, 'ldauu': [0, 0.2], 'gga': 'BF', 'zab_vdw': -1.8867, 'setups': {'H': '_sv'}, 'lwave': False, 'sigma': 0.1, 'luse_vdw': True}

#+BEGIN_SRC python
from vasp import *
from ase import Atom, Atoms

atoms = Atoms([Atom('O', [4, 4.5, 5], magmom=2),
               Atom('O', [4, 4.5, 5], magmom=2),
               Atom('H', [4, 4.5, 15], magmom=2),
               Atom('O', [4, 4.5, 25], magmom=2)],
              cell=(8, 9, 10))

calc = Vasp('molecules/O-sp-triplet-lowsym-sv',
          xc='pbe',
          ismear=0,
          ispin=2,
          sigma=0.01,
          setups={0: 'O_pv', 'O':'_sv'},
          atoms=atoms)


#+END_SRC

#+RESULTS:

I should get this.
: ['potpawPBE/O_pv/POTCAR', 'potpawPBE/O_sv/POTCAR', 'potpawPBE/H/POTCAR']


** Handling setups.
In VASP we have to create the POTCAR file by concatenating existing POTCAR files for each atom into a single file. There are several options for how to do this.

1. Each atom can have its own POTCAR.
2. Common atoms can be grouped to share a POTCAR




#+BEGIN_SRC python
from vasp import *
from ase import Atom, Atoms

atoms = Atoms([Atom('O', [4, 4.5, 5], magmom=2),
               Atom('O', [4, 4.5, 5], magmom=2),
               Atom('H', [4, 4.5, 15], magmom=2),
               Atom('O', [4, 4.5, 25], magmom=2)],
              cell=(8, 9, 10))

setups = [[3, '_pv'], ['O', '_sv']]

pp = 'PBE'

# goal:
# pp = [(3 ,'potpawPBE/O_pv/POTCAR', 1)
#       ('O', 'potpawPBE/O_sv/POTCAR', 2),
#       ('H', 'potpawPBE/H/POTCAR', 1)]
# sort_indices = [3, 0, 1, 2]
ppp = []
sort_indices = []

# First the numeric setups
for setup in [x for x in setups if isinstance(x[0], int)]:
    ppp += [[setup[0],
             'potpaw_{}/{}{}/POTCAR'.format(pp, atoms[setup[0]].symbol, setup[1]),
             1]]
    sort_indices += [setup[0]]

# now the rest of the setups. These are atom symbols
for setup in [x for x in setups if not isinstance(x[0], int)]:
    symbol = setup[0]
    count = 0
    for i, atom in enumerate(atoms):
        if atom.symbol == symbol and i not in sort_indices:
            count += 1
            sort_indices += [i]
    ppp += [[atom.symbol,
             'potpaw_{}/{}{}/POTCAR'.format(pp, symbol, setup[1]),
             count]]

# now the remaining atoms use default potentials
symbols = []
for atom in atoms:
    if atom.symbol not in symbols and atom.symbol not in [x[0] for x in pp]:
        symbols += [atom.symbol]

for symbol in symbols:
    count = 0
    for i, atom in enumerate(atoms):
        if atom.symbol == symbol and i not in sort_indices:
            sort_indices += [i]
            count += 1
    ppp += [[symbol,
             'potpaw_{}/{}/POTCAR'.format(pp, symbol),
             count]]


print symbols
print ppp
print sort_indices


#+END_SRC

#+RESULTS:
: ['O', 'H']
: [[3, 'potpaw_PBE/O_pv/POTCAR', 1], ['O', 'potpaw_PBE/O_sv/POTCAR', 2], ['O', 'potpaw_PBE/O/POTCAR', 0], ['H', 'potpaw_PBE/H/POTCAR', 1]]
: [3, 0, 1, 2]


#+BEGIN_SRC python
from vasp import Vasp
from ase import Atom, Atoms

atoms = Atoms([Atom('O', [4, 4.5, 0], magmom=2),
               Atom('O', [4, 4.5, 1], magmom=2),
               Atom('H', [4, 4.5, 2], magmom=2),
               Atom('O', [4, 4.5, 3], magmom=2)],
              cell=(8, 9, 10))

calc = Vasp('molecules/O-sp-triplet-lowsym-sv',
          xc='pbe',
          ismear=0,
          ispin=2,
          sigma=0.01,
          setups=[[1, '_h'], ['O', '_sv']],
          atoms=atoms)

print calc.sort_indices
print calc.ppp_list
#print calc.atoms_sorted
#print calc.symbol_count

calc.write_poscar('POSCAR')
calc.write_potcar('POTCAR')
#+END_SRC

#+RESULTS:
: [1, 0, 3, 2]
: [[1, 'potpaw_PBE/O_h/POTCAR', 1], ['O', 'potpaw_PBE/O_sv/POTCAR', 2], ['H', 'potpaw_PBE/H/POTCAR', 1]]

#+BEGIN_SRC sh
grep TITEL POTCAR
#+END_SRC

#+RESULTS:
:    TITEL  = PAW_PBE O_h 06Feb2004
:    TITEL  = PAW_PBE O_sv 05Jul2007
:    TITEL  = PAW_PBE H 15Jun2001

#+BEGIN_SRC python
import vasp
print vasp.__file__
print dir(vasp)
print vasp.Vasp
#+END_SRC

#+RESULTS:
: ['Calculator', 'FileIOCalculator', 'Vasp', '__builtins__', '__doc__', '__file__', '__name__', '__package__', 'np', 'os']
: vasp/__init__.pyc
: ['Vasp', '__builtins__', '__doc__', '__file__', '__name__', '__package__', '__path__', 'monkeypatch', 'vasp', 'writers']
: vasp.vasp.Vasp

** spin pol

#+BEGIN_SRC python
from vasp import Vasp
from ase import Atom, Atoms

atoms = Atoms([Atom('O', [5, 5, 5], magmom=2), Atom('H', [0, 0 ,0])],
              cell=(10, 10, 10))

calc = Vasp('molecules/O-sp-triplet',
            xc='PBE',
            encut=400,
            ismear=0,
            ispin=2,  # turn spin-polarization on
            atoms=atoms)

calc.write_incar('INCAR')
print open('INCAR').read()

#+END_SRC

#+RESULTS:
: INCAR created by Atomic Simulation Environment
:  MAGMOMS = 2.0 0.0
:  LCHARGE = .FALSE.
:  ENCUT = 400
:  ISPIN = 2
:  ISMEAR = 0
:  LWAVE = .FALSE.
:  SIGMA = 0.1
:

#+BEGIN_SRC python
from vasp import Vasp
from ase import Atom, Atoms

atoms = Atoms([Atom('O', [5, 5, 5], magmom=2), Atom('H', [0, 0 ,0])],
              cell=(10, 10, 10))

calc = Vasp('molecules/O-sp-triplet',
            xc='PBE',
            encut=400,
            ismear=0,
            magmoms=[2, -2],
            ispin=2,  # turn spin-polarization on
            atoms=atoms)

calc.write_incar('INCAR')
print open('INCAR').read()

#+END_SRC

#+RESULTS:
: INCAR created by Atomic Simulation Environment
:  MAGMOMS = 2 -2
:  LCHARGE = .FALSE.
:  ENCUT = 400
:  ISPIN = 2
:  ISMEAR = 0
:  LWAVE = .FALSE.
:  SIGMA = 0.1
:

** DFT+u
#+BEGIN_SRC python
from vasp import Vasp
from ase import Atom, Atoms

a = 4.27

atoms = Atoms([Atom('Cu',[0,0,0]),
               Atom('Cu',[0.5, 0.5, 0.0]),
               Atom('Cu',[0.5, 0.0, 0.5]),
               Atom('Cu',[0.0, 0.5, 0.5]),
               Atom('O',[0.25, 0.25, 0.25]),
               Atom('O',[0.75, 0.75, 0.75])])

atoms.set_cell((a,a,a), scale_atoms=True)

calc =Vasp('Cu2O-U=4.0',
             ldau=True,   # turn DFT+U on
             ldautype=2,  # select simplified rotationally invariant option
             ldau_luj={'Cu':{'L':2,  'U':4.0, 'J':0.0},
                        'O':{'L':-1, 'U':0.0, 'J':0.0}},
             ldauprint=1,
             ibrion=-1,  #do not rerelax
             nsw=0, atoms=atoms)

calc.write_incar('INCAR')
calc.write_poscar('POSCAR')

print calc.ppp_list
print open('INCAR').read()
print open('POSCAR').read()

#+END_SRC

#+RESULTS:
#+begin_example
[['Cu', 'potpaw_PBE/Cu/POTCAR', 4], ['O', 'potpaw_PBE/O/POTCAR', 2]]
INCAR created by Atomic Simulation Environment
 LCHARGE = .FALSE.
 LDAUL = 2 -1
 LDAUU = 4.0 0.0
 LDAUTYPE = 2
 LDAUJ = 0.0 0.0
 LDAU = .TRUE.
 IBRION = -1
 ISMEAR = 1
 LWAVE = .FALSE.
 SIGMA = 0.1
 LDAUPRINT = 1
 NSW = 0

Cu  O
 1.0000000000000000
     4.2699999999999996    0.0000000000000000    0.0000000000000000
     0.0000000000000000    4.2699999999999996    0.0000000000000000
     0.0000000000000000    0.0000000000000000    4.2699999999999996
   4   2
Cartesian
  0.0000000000000000  0.0000000000000000  0.0000000000000000
  2.1349999999999998  2.1349999999999998  0.0000000000000000
  2.1349999999999998  0.0000000000000000  2.1349999999999998
  0.0000000000000000  2.1349999999999998  2.1349999999999998
  1.0674999999999999  1.0674999999999999  1.0674999999999999
  3.2024999999999997  3.2024999999999997  3.2024999999999997

#+end_example

 LDAUL = -1 2
 LDAUU = 0.000 4.000
 LDAUJ = 0.000 0.000

** updaters

#+BEGIN_SRC python
from ase import Atoms, Atom
from vasp import Vasp

import os
os.environ['ASE_VASP_COMMAND'] = '/home-research/zhongnanxu/opt/vasp-5.3.5/bin/vasp-vtst-beef-serial'

#os.system('rm -fr molecules/co')

atoms = Atoms([Atom('C', [4.42,   5., 5.]),
               Atom('O', [5.58,   5., 5.])],
              cell=[10, 10, 10])

print atoms.positions
calc = Vasp('molecules/co', #output dir
            xc='PBE',  # the exchange-correlation functional
            encut=350, # planewave cutoff
            ibrion=2, nsw=10,
            atoms=atoms)
calc.write_input(atoms)
print
print calc.read()

p = calc.parameters

print calc.set(encut=None)
print p
#+END_SRC

#+RESULTS:
: [[ 4.42  5.    5.  ]
:  [ 5.58  5.    5.  ]]
:
: (Atoms(symbols='CO', positions=..., cell=[10.0, 10.0, 10.0], pbc=[True, True, True]), {'pp': 'PBE', 'ibrion': 2, 'xc': 'pbe', 'lcharge': False, 'ismear': 1, 'lwave': False, 'sigma': 0.1, 'kpts': [1, 1, 1], 'encut': 350, 'nsw': 10})
: {'encut': None}
: {'kpts': [1, 1, 1], 'lcharge': False, 'xc': 'pbe', 'pp': 'PBE', 'encut': None, 'ibrion': 2, 'ismear': 1, 'lwave': False, 'sigma': 0.1, 'nsw': 10}

** Idea for validation

#+BEGIN_SRC python
class Float(object):
    def __init__(self, val):
        self.val = val
        assert isinstance(val, float), '{} is not a float'.format(val)

    def __str__(self):
        return '{} = {}'.format(self.__class__.__name__.upper(), self.val)

class INCAR:
    file = 'INCAR'

class sigma(Float, INCAR):
    """SIGMA determines the width of the smearing in eV."""
    pass

print sigma(0.4)  # this is what would get written
print sigma.file  # this is where it would get written
print sigma.__doc__
#+END_SRC

#+RESULTS:
: SIGMA = 0.4
: INCAR
: SIGMA determines the width of the smearing in eV.
